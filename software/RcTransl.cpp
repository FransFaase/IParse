
#define VERSION "0.1 of March 15, 2015."

/* 
	First some standard definitions.
*/

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
//#include <unistd.h>
#include <ctype.h>
#include <assert.h>

#include "Ident.h"
#include "String.h"
#include "AbstractParseTree.h"
#include "TextFileBuffer.h"
#include "Scanner.h"
#include "ProtosScanner.h"
#include "RcScanner.h"
#include "AbstractParser.h"
#include "BTParser.h"
#include "BTHeapParser.h"
#include "LL1Parser.h"
#include "LL1HeapParser.h"
#include "ParParser.h"
#include "TextReader.h"
#include "XMLParser.h"
#include "XMLStreamer.h"
#include "Dictionary.h"
#include "TMX.h"
#include "Unparser.h"

#define ASSERT assert


bool hasExtenstion(char *filename, char *ext)
{
	int filename_len = strlen(filename);
	int ext_at = filename_len - strlen(ext);
	return    ext_at > 1
		   && filename[ext_at - 1] == '.' 
		   && strcmp(filename + ext_at, ext) == 0;
}


/*
	Initialization of the IParse grammar
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Below the procedure that initializes the Abstract Program Tree
	for the input grammar of IParse itself is given. This was
	generated by calling the procedure print_tree_to_c above.
*/
void init_IParse_grammar( AbstractParseTree& root )
{   /* Generated by IParse version 1.6 of March 15, 2015. */
    AbstractParseTree tt[100];
    int v = 0;

#define NONE tt[v-1].appendChild(AbstractParseTree());
#define ID(I) tt[v-1].appendChild(Ident(I));
#define VAL(V) tt[v-1].appendChild(V);
#define TREE(N) tt[v++].createTree(N);
#define LIST tt[v++].createList();
#define CLOSE if (--v > 0) tt[v-1].appendChild(tt[v]);

    LIST TREE("nt_def") ID("root") 
      LIST TREE("rule") LIST TREE("seq") ID("nt_def") 
          NONE CLOSE 
         ID("eof") CLOSE 
        NONE CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("nt_def") 
      LIST TREE("rule") LIST ID("ident") 
         TREE("literal") VAL(":") 
          NONE CLOSE 
         ID("or_rule") 
         TREE("literal") VAL(".") 
          NONE CLOSE CLOSE 
        ID("nt_def") CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("or_rule") 
      LIST TREE("rule") LIST TREE("chain") ID("rule") 
          NONE 
          VAL("|") CLOSE CLOSE 
        NONE CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("rule") 
      LIST TREE("rule") LIST TREE("opt") TREE("seq") ID("opt_elem") 
           NONE CLOSE 
          NONE CLOSE 
         TREE("opt") LIST TREE("rule") LIST TREE("literal") VAL("[") 
              NONE CLOSE 
             ID("ident") 
             TREE("literal") VAL("]") 
              NONE CLOSE CLOSE 
            NONE CLOSE CLOSE 
          NONE CLOSE CLOSE 
        ID("rule") CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("opt_elem") 
      LIST TREE("rule") LIST ID("list_elem") 
         TREE("literal") VAL("OPT") 
          NONE CLOSE 
         LIST TREE("rule") LIST TREE("literal") VAL("AVOID") 
             NONE CLOSE CLOSE 
           ID("avoid") CLOSE 
          TREE("rule") LIST TREE("literal") VAL("NONGREEDY") 
             NONE CLOSE CLOSE 
           ID("nongreedy") CLOSE 
          TREE("rule") NONE 
           NONE CLOSE CLOSE CLOSE 
        ID("opt") CLOSE 
       TREE("rule") LIST ID("list_elem") CLOSE 
        NONE CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("list_elem") 
      LIST TREE("rule") LIST ID("prim_elem") 
         TREE("literal") VAL("SEQ") 
          NONE CLOSE 
         LIST TREE("rule") LIST TREE("literal") VAL("AVOID") 
             NONE CLOSE CLOSE 
           ID("avoid") CLOSE 
          TREE("rule") NONE 
           NONE CLOSE CLOSE CLOSE 
        ID("seq") CLOSE 
       TREE("rule") LIST ID("prim_elem") 
         TREE("literal") VAL("LIST") 
          NONE CLOSE 
         LIST TREE("rule") LIST TREE("literal") VAL("AVOID") 
             NONE CLOSE CLOSE 
           ID("avoid") CLOSE 
          TREE("rule") NONE 
           NONE CLOSE CLOSE CLOSE 
        ID("list") CLOSE 
       TREE("rule") LIST ID("prim_elem") 
         TREE("literal") VAL("CHAIN") 
          NONE CLOSE 
         LIST TREE("rule") LIST TREE("literal") VAL("AVOID") 
             NONE CLOSE CLOSE 
           ID("avoid") CLOSE 
          TREE("rule") NONE 
           NONE CLOSE CLOSE 
         ID("string") CLOSE 
        ID("chain") CLOSE 
       TREE("rule") LIST ID("prim_elem") CLOSE 
        NONE CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("prim_elem") 
      LIST TREE("rule") LIST ID("string") 
         TREE("opt") LIST TREE("rule") LIST TREE("literal") VAL("*") 
              NONE CLOSE CLOSE 
            ID("local") CLOSE CLOSE 
          NONE CLOSE CLOSE 
        ID("literal") CLOSE 
       TREE("rule") LIST ID("ident") CLOSE 
        NONE CLOSE 
       TREE("rule") LIST TREE("literal") VAL("ident") 
          NONE CLOSE 
         TREE("literal") VAL(">+") 
          NONE CLOSE 
         ID("ident") CLOSE 
        ID("identdefadd") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("ident") 
          NONE CLOSE 
         TREE("literal") VAL(">") 
          NONE CLOSE 
         ID("ident") CLOSE 
        ID("identdef") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("ident") 
          NONE CLOSE 
         TREE("literal") VAL("<") 
          NONE CLOSE 
         ID("ident") CLOSE 
        ID("identuse") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("ident") 
          NONE CLOSE 
         TREE("literal") VAL("!") 
          NONE CLOSE 
         ID("ident") CLOSE 
        ID("identfield") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("ident") 
          NONE CLOSE CLOSE 
        ID("identalone") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("{") 
          NONE CLOSE CLOSE 
        ID("opencontext") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("}") 
          NONE CLOSE CLOSE 
        ID("closecontext") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("\\") 
          NONE CLOSE 
         ID("ident") CLOSE 
        ID("wsterminal") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("(") 
          NONE CLOSE 
         ID("or_rule") 
         TREE("literal") VAL(")") 
          NONE CLOSE CLOSE 
        NONE CLOSE CLOSE CLOSE CLOSE 
	root = tt[0];
}

class ResourceData
{
public:
	ResourceData() : _menus(0), _dialogs(0), _transTableItems(0), _lang("")
	{
		_refTransTableItems = &_transTableItems;
		_refDialogs = &_dialogs;
		_refMenus = &_menus;
	}
	void load(AbstractParseTree resourceTree)
	{
		parse_rules(resourceTree);
	}
	const String& lang() { return _lang; }

	// private(?):
	struct MenuItem;
	struct Menu
	{
		Menu(Ident n_identifier) : identifier(n_identifier), items(0), next(0) {}
		Ident identifier;
		MenuItem *items;
		Menu* next;
	};
	struct MenuItem
	{
		MenuItem(const String& n_content) : content(n_content), popup(0), next(0) {}
		MenuItem(const String& n_content, Ident n_identifier) : content(n_content), identifier(n_identifier), popup(0), next(0) {}
		String content;
		Ident identifier;
		MenuItem* popup;
		MenuItem *next;
	};
	struct DialogItem;
	struct Dialog
	{
		Dialog(Ident n_identifier) : identifier(n_identifier), items(0), next(0) {}
		Ident identifier;
		String caption;
		DialogItem *items;
		Dialog* next;
	};
	enum DialogItemKind { dik_defpushbutton, dik_pushbutton, dik_control, dik_listbox, dik_combobox, 
						  dik_ltext, dik_ctext, dik_rtext, dik_edittext, dik_icon, dik_groupbox };
	struct DialogItem
	{
		DialogItem(DialogItemKind n_kind) : kind(n_kind), nr(-1), next(0) {}
		DialogItemKind kind;
		String content;
		Ident identifier;
		int nr;
		DialogItem *next;
	};
	struct TransTableItem
	{
		TransTableItem(Ident n_identifier, const String& n_content) : identifier(n_identifier), content(n_content), next(0) {}
		Ident identifier;
		String content;
		TransTableItem *next;
	};

	// public(?):
	class MenuIterator
	{
	public:
		MenuIterator(ResourceData &resourceData) : _item(resourceData._menus) {}
		bool more() { return _item != 0; }
		void next() { _item = _item->next; }
		void find(const Ident& ident)
		{ 
			for (; more(); next())
				if (identifier() == ident)
					break;
		}
		Ident identifier() { return _item->identifier; }
		MenuItem *items() { return _item->items; }
	private:
		Menu *_item;
	};
	friend class ResourceData::MenuIterator;
	class DialogIterator
	{
	public:
		DialogIterator(ResourceData &resourceData) : _item(resourceData._dialogs) {}
		bool more() { return _item != 0; }
		void next() { _item = _item->next; }
		void find(const Ident& ident)
		{ 
			for (; more(); next())
				if (identifier() == ident)
					break;
		}
		Ident identifier() { return _item->identifier; }
		const String& caption() { return _item->caption; }
		DialogItem *items() { return _item->items; }
	private:
		Dialog *_item;
	};
	friend class ResourceData::DialogIterator;
	class TransTableIterator
	{
	public:
		TransTableIterator(ResourceData &resourceData) : _item(resourceData._transTableItems) {}
		bool more() { return _item != 0; }
		void next() { _item = _item->next; }
		void find(const Ident& ident)
		{ 
			for (; more(); next())
				if (identifier() == ident)
					break;
		}
		Ident identifier() { return _item->identifier; }
		const String& content() { return _item->content; }
	private:
		TransTableItem *_item;
	};
	friend class ResourceData::TransTableIterator;
private:
	String _lang;
	Menu *_menus;
	Menu **_refMenus;
	Menu* addMenu(Ident ident)
	{
		Menu *newMenu = new Menu(ident);
		*_refMenus = newMenu;
		_refMenus = &newMenu->next;
		return newMenu;
	}
	Dialog *_dialogs;
	Dialog **_refDialogs;
	Dialog* addDialog(Ident ident)
	{
		Dialog *newDialog = new Dialog(ident);
		*_refDialogs = newDialog;
		_refDialogs = &newDialog->next;
		return newDialog;
	}
	TransTableItem *_transTableItems;
	TransTableItem **_refTransTableItems;
	void addTransTableItem(Ident ident, const String& content)
	{
		*_refTransTableItems = new TransTableItem(ident, content);
		_refTransTableItems = &(*_refTransTableItems)->next;
	}
	void parse_rules(AbstractParseTree rules)
	{
		for (AbstractParseTree::iterator it(rules); it.more(); it.next())
		{
			AbstractParseTree rule(it);
			if (rule.isTree("if") || rule.isTree("ifdef") || rule.isTree("ifndef"))
			{
				AbstractParseTree thenPart = rule.part(2);
				parse_rules(thenPart);
				AbstractParseTree elsePart = rule.part(3);
				if (elsePart.isList())
					parse_rules(elsePart);
			}
			else if (rule.isTree("language"))
			{
				AbstractParseTree langTree = rule.part(1);
				const char *lang = langTree.isIdent() ? langTree.identName().val() : "";
				AbstractParseTree subLangTree = rule.part(2);
				const char *sub_lang = subLangTree.isIdent() ? subLangTree.identName().val() : "";
				if (strcmp(lang, "LANG_ENGLISH") == 0 && strcmp(sub_lang, "SUBLANG_ENGLISH_US") == 0)
					_lang = "EN-US";
				else if (strcmp(lang, "LANG_DUTCH") == 0 && strcmp(sub_lang, "SUBLANG_DUTCH") == 0)
					_lang = "NL";
				else if (strcmp(lang, "LANG_FRENCH") == 0 && strcmp(sub_lang, "SUBLANG_FRENCH") == 0)
					_lang = "FR";
				else if (strcmp(lang, "LANG_SLOVAK") == 0 && strcmp(sub_lang, "SUBLANG_SLOVAK_SLOVAKIA") == 0)
					_lang = "SK-SK";
			}
			else if (rule.isTree("menu"))
			{
				Menu* menu = addMenu(rule.part(1).identName());
				parse_menu_group(rule.part(4), &menu->items);
			}
			else if (rule.isTree("dialog") || rule.isTree("dialogex"))
			{
				Dialog* dialog = addDialog(rule.part(1).identName());
				AbstractParseTree caption = rule.part(8);
				if (caption.isString())
					dialog->caption = caption.stringValue();
				AbstractParseTree items = rule.part(rule.isTree("dialog") ? 11 : 12);
				DialogItem** ref_items = &dialog->items;
				for (AbstractParseTree::iterator it(items); it.more(); it.next())
				{
					AbstractParseTree itemTree(it);
					DialogItem* item = 0;
					if (itemTree.isTree("defpushbutton"))
					{	// string "," ident "," int "," int "," int "," int ("," dialogopt)OPT
						item = new DialogItem(dik_defpushbutton);
						item->content = itemTree.part(1).string();
						item->identifier = itemTree.part(2).identName();
					}
					else if (itemTree.isTree("pushbutton"))
					{	// string "," (ident | int) "," int "," int "," int "," int ("," dialogopt)OPT
						item = new DialogItem(dik_pushbutton);
						item->content = itemTree.part(1).stringValue();
						if (itemTree.part(2).isIdent())
							item->identifier = itemTree.part(2).identName();
						else if (itemTree.part(2).isInt())
							item->nr = itemTree.part(2).intValue();
					}
					else if (itemTree.isTree("control"))
					{	// (string | int) "," (ident | int) "," string "," dialogopt "," int "," int "," int "," int ("," dialogopt)OPT
						item = new DialogItem(dik_control);
						if (itemTree.part(1).isString())
							item->content = itemTree.part(1).string();
						if (itemTree.part(2).isIdent())
							item->identifier = itemTree.part(2).identName();
						else if (itemTree.part(2).isInt())
							item->nr = itemTree.part(2).intValue();
					}
					else if (itemTree.isTree("listbox"))
					{	// ident "," int "," int "," int "," int "," dialogopt ("," dialogopt)OPT
						item = new DialogItem(dik_listbox);
						item->identifier = itemTree.part(1).identName();
					}
					else if (itemTree.isTree("combobox"))
					{// "COMBOBOX"		(ident | int)"," int "," int "," int "," int "," dialogopt
						item = new DialogItem(dik_combobox);
						if (itemTree.part(1).isIdent())
							item->identifier = itemTree.part(1).identName();
						else if (itemTree.part(1).isInt())
							item->nr = itemTree.part(1).intValue();
					}
					else if (itemTree.isTree("ltext") || itemTree.isTree("ctext") || itemTree.isTree("rtext"))
					{	// string "," (ident | int) "," int "," int "," int "," int ("," dialogopt)OPT ("," dialogopt)OPT 
						if (itemTree.isTree("ltext"))
							item = new DialogItem(dik_ltext);
						if (itemTree.isTree("ctext"))
							item = new DialogItem(dik_ctext);
						if (itemTree.isTree("rtext"))
							item = new DialogItem(dik_rtext);
						item->content = itemTree.part(1).string();
						if (itemTree.part(2).isIdent())
							item->identifier = itemTree.part(2).identName();
						else if (itemTree.part(2).isInt())
							item->nr = itemTree.part(2).intValue();
					}
					else if (itemTree.isTree("edittext"))
					{	// (ident | int) "," int "," int "," int "," int ("," dialogopt)OPT ("," dialogopt)OPT 
						item = new DialogItem(dik_edittext);
						if (itemTree.part(1).isIdent())
							item->identifier = itemTree.part(1).identName();
						else if (itemTree.part(1).isInt())
							item->nr = itemTree.part(1).intValue();
					}
					else if (itemTree.isTree("icon"))
					{	// (string | int) "," (ident | int) "," int "," int "," int "," int ("," dialogopt)OPT
						item = new DialogItem(dik_icon);
						if (itemTree.part(1).isString())
							item->content = itemTree.part(1).string();
						if (itemTree.part(2).isIdent())
							item->identifier = itemTree.part(2).identName();
						else if (itemTree.part(2).isInt())
							item->nr = itemTree.part(2).intValue();
					}
					else if (itemTree.isTree("groupbox"))
					{	// string "," (ident | int) "," int "," int "," int "," int ("," dialogopt)OPT ("," dialogopt)OPT
						item = new DialogItem(dik_groupbox);
						item->content = itemTree.part(1).string();
						if (itemTree.part(2).isIdent())
							item->identifier = itemTree.part(2).identName();
						else if (itemTree.part(2).isInt())
							item->nr = itemTree.part(2).intValue();
					}
					if (item != 0)
					{
						*ref_items = item;
						ref_items = &item->next;
					}
				}
			}
			else if (rule.isTree("stringtable"))
			{
				for (AbstractParseTree::iterator it2(rule.part(3)); it2.more(); it2.next())
				{
					AbstractParseTree stringtableItem(it2);
					if (stringtableItem.isTree("value"))
					{
						AbstractParseTree identTree = stringtableItem.part(1);
						AbstractParseTree contentTree = stringtableItem.part(2);
						if (identTree.isIdent() && contentTree.isString())
							addTransTableItem(identTree.identName(), contentTree.string());
					}
				}
			}
		}
	}
	void parse_menu_group(AbstractParseTree menu_group, MenuItem** ref_menu_item)
	{
		for (AbstractParseTree::iterator it(menu_group); it.more(); it.next())
		{
			AbstractParseTree item(it);
			if (item.isTree("popup"))
			{
				MenuItem* new_menu_item = new MenuItem(item.part(1).string());
				*ref_menu_item = new_menu_item;
				ref_menu_item = &new_menu_item->next;
				parse_menu_group(item.part(2), &new_menu_item->popup);
			}
			else if (item.isTree("menuitem"))
			{
				MenuItem* new_menu_item = new MenuItem(item.part(1).string(), item.part(2).identName());
				*ref_menu_item = new_menu_item;
				ref_menu_item = &new_menu_item->next;
			}
		}
	}
};

Ident intToIdent(int v)
{
	char buffer[20];
	sprintf(buffer, "%d", v);
	return buffer;
}

void addMenuItems(Dictionary &dictionary, ResourceData::MenuItem *from_item, ResourceData::MenuItem *to_item, Ident menu_ident, int &item_count)
{
	for (; from_item != 0 && to_item != 0; from_item = from_item->next, to_item = to_item->next)
	{
		if (from_item->identifier != to_item->identifier)
		{
			// Menu's do not match
			fprintf(stderr, "Menu's do not match %s %s\n", from_item->identifier.val(), to_item->identifier.val());
			break;
		}

		Ident item_ident = !from_item->identifier.empty() ? from_item->identifier : Ident("null"); //intToIdent(item_count);
		dictionary.add(menu_ident, item_ident, from_item->content, to_item->content);
		item_count++;

		addMenuItems(dictionary, from_item->popup, to_item->popup, menu_ident, item_count);
	}
	// ASSERT(from_item == 0 && to_item == 0);
}

void compareResources(AbstractParseTree firstResource, String firstFileName, AbstractParseTree secondResource, String secondFileName, Dictionary &dictionary)
{
	dictionary.clear();

	ResourceData firstResourceData;
	firstResourceData.load(firstResource);

	ResourceData secondResourceData;
	secondResourceData.load(secondResource);

	dictionary.setLanguages(firstResourceData.lang(), secondResourceData.lang());

	for (ResourceData::MenuIterator firstMenuIt(firstResourceData); firstMenuIt.more(); firstMenuIt.next())
	{
		ResourceData::MenuIterator secondMenuIt(secondResourceData);
		secondMenuIt.find(firstMenuIt.identifier());
		if (secondMenuIt.more())
		{
			int item_count = 0;
			addMenuItems(dictionary, firstMenuIt.items(), secondMenuIt.items(), firstMenuIt.identifier(), item_count);
		}
	}	
	for (ResourceData::DialogIterator firstDialogIt(firstResourceData); firstDialogIt.more(); firstDialogIt.next())
	{
		ResourceData::DialogIterator secondDialogIt(secondResourceData);
		secondDialogIt.find(firstDialogIt.identifier());
		if (secondDialogIt.more())
		{
			String from_caption = firstDialogIt.caption();
			String to_caption = secondDialogIt.caption();
			if (!from_caption.empty() && !to_caption.empty())
				dictionary.add(firstDialogIt.identifier(), "__CAPTION__", from_caption, to_caption);
			ResourceData::DialogItem* from_item = firstDialogIt.items();
			ResourceData::DialogItem* to_item = secondDialogIt.items();
			for (int item_count = 0; from_item != 0 && to_item != 0; from_item = from_item->next, to_item = to_item->next, item_count++)
			{
				if (from_item->kind != to_item->kind || from_item->identifier != to_item->identifier || from_item->nr != to_item->nr)
				{
					fprintf(stderr, "Items in dialog %s do not match %s %s\n", firstDialogIt.identifier().val(), from_item->identifier.val(), to_item->identifier.val());
					break; // dialogs not the same
				}
				if (!from_item->content.empty() && !to_item->content.empty())
				{
					Ident item_ident =   !from_item->identifier.empty() ? from_item->identifier 
						               : from_item->nr > -1 ? intToIdent(from_item->nr)
									   : Ident("null"); //intToIdent(item_count);
					dictionary.add(firstDialogIt.identifier(), item_ident, from_item->content, to_item->content);
				}
			}
			// ASSERT(from_item != 0 && to_item != 0);
		}
	}	
	for (ResourceData::TransTableIterator firstIt(firstResourceData); firstIt.more(); firstIt.next())
	{
		ResourceData::TransTableIterator secondIt(secondResourceData);
		secondIt.find(firstIt.identifier());
		if (secondIt.more())
			dictionary.add(Ident(), firstIt.identifier(), firstIt.content(), secondIt.content());
	}
	//dictionary.establishMajorVariants();
}

bool findFirstTree(const AbstractParseTree& tree, Ident name, AbstractParseTree::iterator &resultIt)
{
	static Ident id_dialog("dialog");
	static Ident id_dialogex("dialogex");

	if (!tree.isList() && !tree.isTree())
		return false;

	for (AbstractParseTree::iterator it(tree); it.more(); it.next())
	{
		AbstractParseTree child_tree(it);
		if (child_tree.isTree(name) || (name == id_dialog && child_tree.isTree(id_dialogex)))
		{
			resultIt = it;
			return true;
		}
		else if (findFirstTree(child_tree, name, resultIt))
			return true;
	}
	return false;
}

void translateMenu(AbstractParseTreeCursor menu, Ident menu_id, Dictionary &dictionary)
{
	static Ident id_popup("popup");
	static Ident id_menuitem("menuitem");

	for (AbstractParseTreeIteratorCursor menuIt(menu); menuIt.more(); menuIt.next())
	{
		AbstractParseTreeCursor menuItem(menuIt);
		if (menuItem.isTree(id_popup))
		{
			String translation;
			if (dictionary.translate(menuItem.part(1).stringValue(), translation))
			{
				menuItem.part(1).replaceBy(translation);
			}
			translateMenu(menuItem.part(2), menu_id, dictionary);
		}
		else if (menuItem.isTree(id_menuitem))
		{
			String translation;
			if (dictionary.translate(menuItem.part(1).stringValue(), menu_id, menuItem.part(2).identName(), translation))
			{
				menuItem.part(1).replaceBy(translation);
			}
		}
	}
}


void translateResource(AbstractParseTree firstResource, AbstractParseTreeIteratorCursor translCursorIt, Dictionary &dictionary)
{
	static Ident id_emptyline("emptyline");
	static Ident id_if("if");
	static Ident id_ifdef("ifdef");
	static Ident id_ifndef("ifndef");
	static Ident id_menu("menu");
	static Ident id_dialog("dialog");
	static Ident id_dialogex("dialogex");
	static Ident id_stringtable("stringtable");
	static Ident id_value("value");

	while(translCursorIt.more())
	{
		AbstractParseTreeCursor translPart(translCursorIt);
		if (translPart.isTree(id_if) || translPart.isTree(id_ifdef) || translPart.isTree(id_ifndef))
		{
			/*
				| "#if" \s condition "\n" rules ("#else" "\n" rules)OPT "#endif" comment OPT "\n" [if]
				| "#ifdef" ident "\n" rules ("#else" "\n" rules)OPT "#endif" comment OPT "\n" [ifdef]
				| "#ifndef" ident "\n" rules ("#else" "\n" rules)OPT "#endif" comment OPT "\n" [ifndef]
			*/

			translateResource(firstResource, translPart.part(2), dictionary);
			if (translPart.part(3).isList())
				translateResource(firstResource, translPart.part(3), dictionary);
			translCursorIt.next();
		}
		else if (translPart.isTree(id_menu))
		{
			for (; translCursorIt.more(); translCursorIt.erase())
			{
				translPart = translCursorIt;
				if (!translPart.isTree(id_menu) && !translPart.isTree(id_emptyline))
					break;
			}
			AbstractParseTree::iterator menuFromFirstIt;
			if (findFirstTree(firstResource, id_menu, menuFromFirstIt))
			{
				for (; menuFromFirstIt.more(); menuFromFirstIt.next())
				{
					AbstractParseTree menuFromFirst(menuFromFirstIt);
					if (!menuFromFirst.isTree(id_menu) && !menuFromFirst.isTree(id_emptyline))
						break;
					// insert
					translCursorIt.insert(menuFromFirst);
					if (menuFromFirst.isTree(id_menu))
					{
						// translate
						AbstractParseTreeCursor menu(translCursorIt);
						translateMenu(menu.part(4), menu.part(1).identName(), dictionary);
					}
					translCursorIt.next();
				}
			}
		}
		else if (translPart.isTree(id_dialog) || translPart.isTree(id_dialogex))
		{
			for (; translCursorIt.more(); translCursorIt.erase())
			{
				translPart = translCursorIt;
				if (!translPart.isTree(id_dialog) && !translPart.isTree(id_dialogex) && !translPart.isTree(id_emptyline))
					break;
			}
			AbstractParseTree::iterator dialogFromFirstIt;
			if (findFirstTree(firstResource, id_dialog, dialogFromFirstIt))
			{
				for (; dialogFromFirstIt.more(); dialogFromFirstIt.next())
				{
					AbstractParseTree dialogFromFirst(dialogFromFirstIt);
					if (!dialogFromFirst.isTree(id_dialog) && !dialogFromFirst.isTree(id_dialogex) && !dialogFromFirst.isTree(id_emptyline))
						break;
					// insert
					translCursorIt.insert(dialogFromFirst);
					if (dialogFromFirst.isTree(id_dialog) || dialogFromFirst.isTree(id_dialogex))
					{
						// translate
						AbstractParseTreeCursor dialog(translCursorIt);
						Ident dialog_id = dialog.part(1).identName();
						int itemspart = dialogFromFirst.isTree(id_dialog) ? 11 : 12;
						for (AbstractParseTreeIteratorCursor itemIt(dialog.part(itemspart)); itemIt.more(); itemIt.next())
						{
							AbstractParseTreeCursor item(itemIt);
							int string_pos = 0;
							Ident item_id;
							int item_nr = -1;
							if (item.isTree("defpushbutton"))
							{	// string "," ident "," int "," int "," int "," int ("," dialogopt)OPT
								string_pos = 1;
								item_id = item.part(2).identName();
							}
							else if (item.isTree("pushbutton"))
							{	// string "," (ident | int) "," int "," int "," int "," int ("," dialogopt)OPT
								string_pos = 1;
								if (item.part(2).isIdent())
									item_id = item.part(2).identName();
								else if (item.part(2).isInt())
									item_nr = item.part(2).intValue();
							}
							else if (item.isTree("control"))
							{	// (string | int) "," (ident | int) "," string "," dialogopt "," int "," int "," int "," int ("," dialogopt)OPT
								if (item.part(1).isString())
									string_pos = 1;
								if (item.part(2).isIdent())
									item_id = item.part(2).identName();
								else if (item.part(2).isInt())
									item_nr = item.part(2).intValue();
							}
							else if (item.isTree("listbox"))
							{	// ident "," int "," int "," int "," int "," dialogopt ("," dialogopt)OPT
								item_id = item.part(1).identName();
							}
							else if (item.isTree("combobox"))
							{// "COMBOBOX"		(ident | int)"," int "," int "," int "," int "," dialogopt
								if (item.part(1).isIdent())
									item_id = item.part(1).identName();
								else if (item.part(1).isInt())
									item_nr = item.part(1).intValue();
							}
							else if (item.isTree("ltext") || item.isTree("ctext") || item.isTree("rtext"))
							{	// string "," (ident | int) "," int "," int "," int "," int ("," dialogopt)OPT ("," dialogopt)OPT 
								string_pos = 1;
								if (item.part(2).isIdent())
									item_id = item.part(2).identName();
								else if (item.part(2).isInt())
									item_nr = item.part(2).intValue();
							}
							else if (item.isTree("edittext"))
							{	// (ident | int) "," int "," int "," int "," int ("," dialogopt)OPT ("," dialogopt)OPT 
								if (item.part(1).isIdent())
									item_id = item.part(1).identName();
								else if (item.part(1).isInt())
									item_nr = item.part(1).intValue();
							}
							else if (item.isTree("icon"))
							{	// (string | int) "," (ident | int) "," int "," int "," int "," int ("," dialogopt)OPT
								if (item.part(1).isString())
									string_pos = 1;
								if (item.part(2).isIdent())
									item_id = item.part(2).identName();
								else if (item.part(2).isInt())
									item_nr = item.part(2).intValue();
							}
							else if (item.isTree("groupbox"))
							{	// string "," (ident | int) "," int "," int "," int "," int ("," dialogopt)OPT ("," dialogopt)OPT
								string_pos = 1;
								if (item.part(2).isIdent())
									item_id = item.part(2).identName();
								else if (item.part(2).isInt())
									item_nr = item.part(2).intValue();
							}
							if (string_pos > 0)
							{
								String translation;
								if (  item_id.empty()
									? dictionary.translate(item.part(string_pos).stringValue(), translation)
									: dictionary.translate(item.part(string_pos).stringValue(), dialog_id, item_id, translation))
								{
									item.part(string_pos).replaceBy(translation);
								}
							}
						}
					}
					translCursorIt.next();
				}
			}
		}
		else if (translPart.isTree(id_stringtable))
		{
			for (; translCursorIt.more(); translCursorIt.erase())
			{
				translPart = translCursorIt;
				if (!translPart.isTree(id_stringtable) && !translPart.isTree(id_emptyline))
					break;
			}
			AbstractParseTree::iterator stringtableFromFirstIt;
			if (findFirstTree(firstResource, id_stringtable, stringtableFromFirstIt))
			{
				for (; stringtableFromFirstIt.more(); stringtableFromFirstIt.next())
				{
					AbstractParseTree stringtableFromFirst(stringtableFromFirstIt);
					if (!stringtableFromFirst.isTree(id_stringtable) && !stringtableFromFirst.isTree(id_emptyline))
						break;
					// insert
					translCursorIt.insert(stringtableFromFirst);
					if (stringtableFromFirst.isTree(id_stringtable))
					{
						// translate
						AbstractParseTreeCursor stringtable(translCursorIt);
						for (AbstractParseTreeIteratorCursor itemIt(stringtable.part(3)); itemIt.more(); itemIt.next())
						{
							AbstractParseTreeCursor item(itemIt);
							ASSERT(item.isTree(id_value) && item.nrParts() == 2);
							String translation;
							if (dictionary.translate(item.part(2).stringValue(), Ident(), item.part(1).identName(), translation))
							{
								item.part(2).replaceBy(translation);
							}
						}
					}
					translCursorIt.next();
				}
			}
		}
		else
			translCursorIt.next();
	}
}

void translateResource(AbstractParseTree firstResource, AbstractParseTree secondResource, Dictionary &dictionary, AbstractParseTree &translResource)
{
	
	translResource = secondResource;
	AbstractParseTreeCursor translResourceCursor(translResource);
	AbstractParseTreeIteratorCursor translResourceItCur(translResourceCursor);
	
	translateResource(firstResource, translResourceItCur, dictionary);

	/*
	// Copy first part (till first menu definition) of second resource file to translated resource file
	AbstractParseTree::iterator secondIt(secondResource);
	for (; secondIt.more(); secondIt.next())
	{
		AbstractParseTree line(secondIt);
		if (line.isTree(id_menu))
			break;
		translResource.appendChild(line);
	}
	// Find first menu definition in first resource
	AbstractParseTree::iterator firstIt(secondResource);
	for (; firstIt.more(); firstIt.next())
	{
		AbstractParseTree line(firstIt);
		if (line.isTree(id_menu))
			break;
	}

	Ident id_comment("comment");

	translResource = firstResource;
	AbstractParseTreeCursor translResourceCursor(translResource);
	AbstractParseTreeIteratorCursor translResourceItCur(translResourceCursor);

	AbstractParseTree::iterator secondIt(secondResource);

	// Find comment with language name
	for (; translResourceItCur.more(); translResourceItCur.next())
	{
		AbstractParseTreeCursor line(translResourceItCur);
		if (line.isTree(id_comment) && line.part(1).isString())
		{
			const char* comment = line.part(1).stringValue();
			if (strstr(comment, " resources") != 0)
				break;
		}
	}
	if (!translResourceItCur.more()) { assert(0); return; }
	for (; secondIt.more(); secondIt.next())
	{
		AbstractParseTree line(secondIt);
		if (line.isTree(id_comment) && line.part(1).isString())
		{
			const char* comment = line.part(1).stringValue();
			if (strstr(comment, " resources") != 0)
				break;
		}
	}
	if (!translResourceItCur.more()) { assert(0); return; }
	AbstractParseTreeCursor(translResourceItCur).replaceBy(secondIt);
	*/
}

class UnparseErrorCollector : public AbstractUnparseErrorCollector
{
public:
	UnparseErrorCollector(FILE *f) : _f(f) {}
	virtual void errorDifferentRulesWithSameType(Ident type, GrammarRule* rule1, GrammarRule* rule2)
	{
		fprintf(_f, "Error: different rules with type %s\n", type.val());
		print_rule(rule1);
		print_rule(rule2);
	}
	virtual void warningTypeReachedThroughDifferentPaths(Ident type, GrammarRule* rule, GrammarRule *rule1, GrammarRule *rule2)
	{
		fprintf(_f, "Warning: rule for type %s reached through different paths\n", type.val());
		print_rule(rule);
		print_rule(rule1);
		print_rule(rule2);
	}
private:
	void print_rule(GrammarRule* rule)
	{
		if (rule != 0)
		{
			fprintf(_f, "\t%d.%d ", rule->line, rule->column);
			rule->print(_f);
			fprintf(_f, "\n");
		}
		else
			fprintf(_f, "\t<empty rule>\n");
	}
	FILE *_f;
};


int main(int argc, char *argv[])
{
    if (argc == 1)
    {   printf("Usage: %s\n", argv[0]);
		return 0;
	}

#ifdef _DEBUG
	AbstractParseTreeUnitTest();
#endif

	/* Test:
	const char* filename = argv[1];
    FILE *fin = fopen(filename, "rt");

    if (fin != 0)
    {
		TextFileBuffer textBuffer;
		PlainFileReader plainFileReader;
		plainFileReader.read(fin, textBuffer);
		XMLParser xmlParser;
		AbstractParseTree result;
		xmlParser.parse(textBuffer, result);

		FILE *fout = fopen("out.txt", "wt");
		if (fout != 0)
		{
			XMLStreamer streamer(fout, /*compact* /false);
			print_xml_apt(streamer, result);
		}
	}
	*/
	AbstractParseTree rcGrammarTree;
	{
		FILE *f = fopen("rc.gr", "rt");
		if (f == 0)
		{
			fprintf(stderr, "Error: cannot open rc.gr\n");
			return 0;
		}
		TextFileBuffer textBuffer;
		PlainFileReader plainFileReader;
		plainFileReader.read(f, textBuffer);
		fclose(f);

		AbstractParseTree grammarTree;
		init_IParse_grammar(grammarTree);
		BTParser* parser = new BTParser();
		BasicScanner* scanner = new BasicScanner();
		parser->setScanner(scanner);
		parser->loadGrammar(grammarTree);
		if (!parser->parse(textBuffer, "root", rcGrammarTree))
		{
			parser->printExpected(stdout, "tc.gr", textBuffer);
			return 0;
		}
		delete scanner;
		delete parser;
	}

	PlainFileReader plainFileReader;

	CodePage1252 codePage1252;
	CodePageToUF8ConverterStream codePage1252ToUF8ConverterStream(codePage1252);
	ConverterFileReader codePage1252FileReader(codePage1252ToUF8ConverterStream);
	UTF16ToUTF8ConverterStream utf16ToUTF8ConverterStream;
	ConverterFileReader utf16FileReader(utf16ToUTF8ConverterStream);
	AbstractFileReader *selected_file_reader = &plainFileReader;

	UTF8ToCodePageConverterStream utf8ToCodePageConverterStream(codePage1252);
	UTF8ToUTF16ConverterStream utf8ToUTF16ConverterStream;
	ConverterStream<char, char> *selected_output_converter = 0;

	AbstractParseTree firstResource;
	String firstFileName;
	AbstractParseTree secondResource;
	String secondFileName;
	Dictionary dictionary;

	//bool diff_alphabetic = true;
	//bool diff_with_id = false;
	bool silent = false;
    for (int i = 1; i < argc; i++)
    {   char *arg = argv[i];

        if (!strcmp(arg, "-s"))
			silent = true;
		
		if (!silent)
		{
			if (i == 1)
			    fprintf(stderr, "RcTransl, Version: %s\n", VERSION);
        	printf("Processing: %s\n", arg); 
		}

		/*
        if (!strcmp(arg, "+alpha"))
            diff_alphabetic = true;
        else if (!strcmp(arg, "-alpha"))
            diff_alphabetic = false;
        else if (!strcmp(arg, "+withid"))
            diff_with_id = true;
        else if (!strcmp(arg, "-withid"))
            diff_with_id = false;
		else
		*/
		if ((!strcmp(arg, "-multiple") || !strcmp(arg, "-diff")) && i + 1 < argc)
        {
			if (firstResource.isEmpty() || secondResource.isEmpty())
				fprintf(stderr, "Error: two resource files are needed for -multiple\n");
			else
			{
				char *file_name = argv[i+1];
				FILE *fout = !strcmp(file_name, "-") 
							 ? stdout : fopen(file_name, "wt");
				if (fout == 0)
					fprintf(stderr, "Error: cannot open %s for writing\n", file_name);
				else
				{
					compareResources(firstResource, firstFileName, secondResource, secondFileName, dictionary);
					if (!strcmp(arg, "-multiple"))
						dictionary.printMultiple(fout);
					else
						TMX::saveToOmegaT(fout, dictionary, firstFileName);
					if (strcmp(file_name, "-") != 0)
						fclose(fout);
				}
			}
			i++;
		}
		else if (!strcmp(arg, "-transl") && i + 1 < argc)
		{
			char *file_name = argv[i+1];
			FILE *fout = !strcmp(file_name, "-") 
						 ? stdout : fopen(file_name, "wb");
			if (fout == 0)
				fprintf(stderr, "Error: cannot open %s for writing\n", file_name);
			else
			{
				AbstractParseTree translResource;
				translateResource(firstResource, secondResource, dictionary, translResource);

				CharStreamToFile charToFileStream(fout, false);
				ResourceTerminalUnparser termUnparser;
				Unparser unparser;
				unparser.setTerminalUnparser(&termUnparser);
				UnparseErrorCollector unparseErrorCollector(stderr);
				unparser.loadGrammarForUnparse(rcGrammarTree, &unparseErrorCollector);
				AbstractStream<char> *outStream;
				if (selected_output_converter == 0)
					outStream = &charToFileStream;
				else
				{
					selected_output_converter->setOutputStream(&charToFileStream);
					outStream = selected_output_converter;
				}
				unparser.unparse(translResource, "root", outStream);

				if (strcmp(file_name, "-") != 0)
					fclose(fout);
			}
			i++;
		}
		/*
		else if (!strcmp(arg, "-print") && i + 1 < argc)
		{
			char *file_name = argv[i+1];
			FILE *fout = !strcmp(file_name, "-") 
						 ? stdout : fopen(file_name, "wb");
			if (fout == 0)
				fprintf(stderr, "Error: cannot open %s for writing\n", file_name);
			else
			{
				//tmx.saveAs(fout, diff_with_id, diff_alphabetic);
				if (strcmp(file_name, "-") != 0)
					fclose(fout);
			}
			i++;
		}*/
		else if (!strcmp(arg, "-unparse") && i + 1 < argc)
		{
			char *file_name = argv[i+1];
			FILE *fout = !strcmp(file_name, "-") 
						 ? stdout : fopen(file_name, "wb");
			if (fout == 0)
				fprintf(stderr, "Error: cannot open %s for writing\n", file_name);
			else
			{
				CharStreamToFile charToFileStream(fout, false);
				ResourceTerminalUnparser termUnparser;
				Unparser unparser;
				unparser.setTerminalUnparser(&termUnparser);
				UnparseErrorCollector unparseErrorCollector(stderr);
				unparser.loadGrammarForUnparse(rcGrammarTree, &unparseErrorCollector);
				AbstractStream<char> *outStream;
				if (selected_output_converter == 0)
					outStream = &charToFileStream;
				else
				{
					selected_output_converter->setOutputStream(&charToFileStream);
					outStream = selected_output_converter;
				}
				unparser.unparse(firstResource, "root", outStream);

				if (strcmp(file_name, "-") != 0)
					fclose(fout);
			}
			i++;
		}
		else if (!strcmp(arg, "-cp1252"))
		{
			selected_file_reader = &codePage1252FileReader;
			selected_output_converter = &utf8ToCodePageConverterStream;
		}
		else if (!strcmp(arg, "-utf8"))
		{
			selected_file_reader = &plainFileReader;
			selected_output_converter = 0;
		}
		else if (!strcmp(arg, "-utf16"))
		{
			selected_file_reader = &utf16FileReader;
			selected_output_converter = &utf8ToUTF16ConverterStream;
		}
        else if (!strcmp(arg, "-p") && i + 1 < argc)
        {
			char *file_name = argv[++i];
			FILE *fout = !strcmp(file_name, "-") 
						 ? stdout : fopen(file_name, "wt");
			if (fout == 0)
				fprintf(stderr, "Error: cannot open %s for writing\n", file_name);
			else if (secondResource.isEmpty())
			{
				firstResource.print(fout, false);
				fclose(fout);
			}
			else
			{
				secondResource.print(fout, false);
				fclose(fout);
			}
			i++;
        }
		else if (hasExtenstion(arg, "rc"))
		{
			FILE *f = fopen(arg, "rb");
			if (f == 0)
			{
				fprintf(stderr, "Error: cannot open resource file %s\n", arg);
				return 0;
			}

			TextFileBuffer textBuffer;
			selected_file_reader->read(f, textBuffer);
			fclose(f);

			BTParser *parser = new BTParser();
			ResourceScanner *scanner = new ResourceScanner();
			parser->setScanner(scanner);
			parser->loadGrammar(rcGrammarTree);
			AbstractParseTree new_tree;
			if (!parser->parse(textBuffer, "root", new_tree))
			{
				parser->printExpected(stdout, arg, textBuffer);
				return 0;
			}
			if (firstResource.isEmpty())
			{
				firstResource = new_tree;
				firstFileName = arg;
			}
			else
			{
				secondResource = new_tree;
				secondFileName = arg;
			}
		}
		else if (hasExtenstion(arg, "tmx"))
		{
			FILE *f = fopen(arg, "rt");
			if (f == 0)
			{
				fprintf(stderr, "Error: cannot open resource file %s\n", arg);
				return 0;
			}
			TMX::loadFromOmegaT(f, dictionary);
			fclose(f);
		}
	}

	return 0;
}
