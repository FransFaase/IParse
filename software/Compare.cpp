#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <ctype.h>
//#include <assert.h>

#include "Ident.h"
#include "AbstractParseTree.h"
#include "TextFileBuffer.h"
#include "Scanner.h"
//#include "ProtosScanner.h"
//#include "RcScanner.h"
//#include "PascalScanner.h"
#include "AbstractParser.h"
#include "ParserGrammar.h"
#include "BTParser.h"
//#include "BTHeapParser.h"
//#include "LL1Parser.cpp"
//#include "LL1HeapParser.h"
//#include "ParParser.h"
#include "TextReader.h"
//#include "XMLParser.h"
#include "CodePages.h"
#include "Streams.h"
#include "Unparser.h"

#include "insertonlymap.h"

/*
	Initialization of the IParse grammar
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Below the procedure that initializes the Abstract Program Tree
	for the input grammar of IParse itself is given. This was
	generated by calling the procedure print_tree_to_c above.
*/
void init_IParse_grammar( AbstractParseTree& root )
{   /* Generated by IParse version 1.6 of March 15, 2015. */
    AbstractParseTree tt[100];
    int v = 0;

#define NONE tt[v-1].appendChild(AbstractParseTree());
#define ID(I) tt[v-1].appendChild(Ident(I));
#define VAL(V) tt[v-1].appendChild(V);
#define TREE(N) tt[v++].createTree(N);
#define LIST tt[v++].createList();
#define CLOSE if (--v > 0) tt[v-1].appendChild(tt[v]);

    LIST TREE("nt_def") ID("root") 
      LIST TREE("rule") LIST TREE("seq") ID("nt_def") 
          NONE CLOSE 
         ID("eof") CLOSE 
        NONE CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("nt_def") 
      LIST TREE("rule") LIST ID("ident") 
         TREE("literal") VAL(":") 
          NONE CLOSE 
         ID("or_rule") 
         TREE("literal") VAL(".") 
          NONE CLOSE CLOSE 
        ID("nt_def") CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("or_rule") 
      LIST TREE("rule") LIST TREE("chain") ID("rule") 
          NONE 
          VAL("|") CLOSE CLOSE 
        NONE CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("rule") 
      LIST TREE("rule") LIST TREE("opt") TREE("seq") ID("opt_elem") 
           NONE CLOSE 
          NONE CLOSE 
         TREE("opt") LIST TREE("rule") LIST TREE("literal") VAL("[") 
              NONE CLOSE 
             ID("ident") 
             TREE("literal") VAL("]") 
              NONE CLOSE CLOSE 
            NONE CLOSE CLOSE 
          NONE CLOSE CLOSE 
        ID("rule") CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("opt_elem") 
      LIST TREE("rule") LIST ID("list_elem") 
         TREE("literal") VAL("OPT") 
          NONE CLOSE 
         LIST TREE("rule") LIST TREE("literal") VAL("AVOID") 
             NONE CLOSE CLOSE 
           ID("avoid") CLOSE 
          TREE("rule") LIST TREE("literal") VAL("NONGREEDY") 
             NONE CLOSE CLOSE 
           ID("nongreedy") CLOSE 
          TREE("rule") NONE 
           NONE CLOSE CLOSE CLOSE 
        ID("opt") CLOSE 
       TREE("rule") LIST ID("list_elem") CLOSE 
        NONE CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("list_elem") 
      LIST TREE("rule") LIST ID("prim_elem") 
         TREE("literal") VAL("SEQ") 
          NONE CLOSE 
         LIST TREE("rule") LIST TREE("literal") VAL("AVOID") 
             NONE CLOSE CLOSE 
           ID("avoid") CLOSE 
          TREE("rule") NONE 
           NONE CLOSE CLOSE CLOSE 
        ID("seq") CLOSE 
       TREE("rule") LIST ID("prim_elem") 
         TREE("literal") VAL("LIST") 
          NONE CLOSE 
         LIST TREE("rule") LIST TREE("literal") VAL("AVOID") 
             NONE CLOSE CLOSE 
           ID("avoid") CLOSE 
          TREE("rule") NONE 
           NONE CLOSE CLOSE CLOSE 
        ID("list") CLOSE 
       TREE("rule") LIST ID("prim_elem") 
         TREE("literal") VAL("CHAIN") 
          NONE CLOSE 
         LIST TREE("rule") LIST TREE("literal") VAL("AVOID") 
             NONE CLOSE CLOSE 
           ID("avoid") CLOSE 
          TREE("rule") NONE 
           NONE CLOSE CLOSE 
         ID("string") CLOSE 
        ID("chain") CLOSE 
       TREE("rule") LIST ID("prim_elem") CLOSE 
        NONE CLOSE CLOSE CLOSE 
     TREE("nt_def") ID("prim_elem") 
      LIST TREE("rule") LIST ID("string") 
         TREE("opt") LIST TREE("rule") LIST TREE("literal") VAL("*") 
              NONE CLOSE CLOSE 
            ID("local") CLOSE CLOSE 
          NONE CLOSE CLOSE 
        ID("literal") CLOSE 
       TREE("rule") LIST ID("ident") CLOSE 
        NONE CLOSE 
       TREE("rule") LIST TREE("literal") VAL("ident") 
          NONE CLOSE 
         TREE("literal") VAL(">+") 
          NONE CLOSE 
         ID("ident") CLOSE 
        ID("identdefadd") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("ident") 
          NONE CLOSE 
         TREE("literal") VAL(">") 
          NONE CLOSE 
         ID("ident") CLOSE 
        ID("identdef") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("ident") 
          NONE CLOSE 
         TREE("literal") VAL("<") 
          NONE CLOSE 
         ID("ident") CLOSE 
        ID("identuse") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("ident") 
          NONE CLOSE 
         TREE("literal") VAL("!") 
          NONE CLOSE 
         ID("ident") CLOSE 
        ID("identfield") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("ident") 
          NONE CLOSE CLOSE 
        ID("identalone") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("{") 
          NONE CLOSE CLOSE 
        ID("opencontext") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("}") 
          NONE CLOSE CLOSE 
        ID("closecontext") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("\\") 
          NONE CLOSE 
         ID("ident") CLOSE 
        ID("wsterminal") CLOSE 
       TREE("rule") LIST TREE("literal") VAL("(") 
          NONE CLOSE 
         ID("or_rule") 
         TREE("literal") VAL(")") 
          NONE CLOSE CLOSE 
        NONE CLOSE CLOSE CLOSE CLOSE 
	root = tt[0];
}

bool parse_dataSrc(AbstractParseTree &dataSrcGrammarTree, AbstractParseTree &dataSrcTree)
{
	AbstractParseTree mgrTree;
	init_IParse_grammar(mgrTree);

	FILE *fgr = fopen("..\\..\\PS\\PS_ws_js.gr", "rt");
	TextFileBuffer grTextBuffer;
	PlainFileReader plainFileReader;
	plainFileReader.read(fgr, grTextBuffer);
	fclose(fgr);
	BTParser grParser;
	BasicScanner basicScanner;
	grParser.setScanner(&basicScanner);
	grParser.loadGrammar(mgrTree);

	if (!grParser.parse(grTextBuffer, "root", dataSrcGrammarTree))
	{
		grParser.printExpected(stdout, "PS_ws_js.gr", grTextBuffer);
		return false;
	}
	
	FILE *fdata = fopen("..\\..\\PS\\dataSrc.js", "rt");
	TextFileBuffer dataTextBuffer;
	plainFileReader.read(fdata, dataTextBuffer);
	fclose(fdata);
	BTParser dataParser;
	WhiteSpaceScanner whiteSpaceScanner;
	dataParser.setScanner(&whiteSpaceScanner);
	dataParser.loadGrammar(dataSrcGrammarTree);
	
	if (!dataParser.parse(dataTextBuffer, "root", dataSrcTree))
	{
		dataParser.printExpected(stdout, "dataSrc.js", dataTextBuffer);
		return false;
	}
	return true;
}

void unparse_dataSrc(const char* fn, const AbstractParseTree& dataSrcGrammarTree, const AbstractParseTree& dataSrcTree)
{
	FILE *fout = fopen(fn, "wt");	
	CharStreamToFile charToFileStream(fout, /*text*/false);
	WhiteSpaceTerminalUnparser whiteSpaceTerminalUnparser;
	Unparser unparser;
	unparser.setTerminalUnparser(&whiteSpaceTerminalUnparser);
	class UnparseErrorCollector : public AbstractUnparseErrorCollector
	{
	public:
		UnparseErrorCollector(FILE *f) : _f(f) {}
		virtual void errorDifferentRulesWithSameType(Ident type, GrammarRule* rule1, GrammarRule* rule2)
		{
			fprintf(_f, "Error: different rules with type %s\n", type.val());
			print_rule(rule1);
			print_rule(rule2);
		}
		virtual void warningTypeReachedThroughDifferentPaths(Ident type, GrammarRule* rule, GrammarRule *rule1, GrammarRule *rule2)
		{
			fprintf(_f, "Warning: rule for type %s reached through different paths\n", type.val());
			print_rule(rule);
			print_rule(rule1);
			print_rule(rule2);
		}
	private:
		void print_rule(GrammarRule* rule)
		{
			if (rule != 0)
			{
				fprintf(_f, "\t%d.%d ", rule->line, rule->column);
				if (rule != 0)
					rule->print(_f);
				fprintf(_f, "\n");
			}
			else
				fprintf(_f, "\t<empty rule>\n");
		}
		FILE *_f;
	};
	UnparseErrorCollector unparseErrorCollector(stderr);
	unparser.loadGrammarForUnparse(dataSrcGrammarTree, &unparseErrorCollector);
	unparser.unparse(dataSrcTree, "root", &charToFileStream);
}

bool getTreeInList(AbstractParseTreeCursor dataSrcTC, Ident treeName, AbstractParseTreeCursor &result)
{
	for (AbstractParseTreeIteratorCursor treeIt(dataSrcTC); treeIt.more(); treeIt.next())
	{
		if (treeIt.isTree(treeName))
		{
			result = treeIt;
			return true;
		}
	}
	return false;
}

bool getMemberInList(AbstractParseTreeCursor list, Ident memberName, AbstractParseTreeCursor &memberValue)
{
	for (AbstractParseTreeIteratorCursor listIt(list); listIt.more(); listIt.next())
	{
		AbstractParseTreeCursor listElem(listIt);
		if (listElem.isList())
		{
			if (listElem.part(2).isTree(memberName))
			{
				memberValue = listElem.part(2).part(1);
				return true;
			}
		}
	}
	return false;
}

const char* getStringMemberValueInList(AbstractParseTreeCursor list, Ident memberName)
{
	AbstractParseTreeCursor memberValue;
	if (getMemberInList(list, memberName, memberValue))
	{
		if (memberValue.isString())
			return memberValue.stringValue();
	}
	return "";
}

struct Srcs;
struct Book;
struct Exhibition;
struct Work;
struct WorkExhibition;
struct WorkBook;

struct FileUse
{
	FileUse(Srcs* n_in_src) : in_src(n_in_src), next(0) {}
	Srcs* in_src;
	FileUse* next;
};

struct File
{
	File(const String& n_key) : key(n_key), in_srcs(0) {}
	const String key;
	void add(Srcs* srcs)
	{
		FileUse** ref = &in_srcs;
		while (*ref != 0)
			ref = &(*ref)->next;
		*ref = new FileUse(srcs);
	}
	bool inSrcs() { return in_srcs != 0; }
	class SrcsIterator
	{
	public:
		SrcsIterator(const File& file) : _cur(file.in_srcs) {}
		bool more() const { return _cur != 0; }
		void next() { _cur = _cur->next; }
		Srcs* value() { return _cur->in_src; }
	private:
		FileUse* _cur;
	};
private:
	FileUse* in_srcs;
};

typedef InsertOnlyMap<String, File> Files;
Files files;

struct Src
{
	friend struct Srcs;
	Src(const AbstractParseTreeCursor& n_dataTC, File* n_file, const char *n_title, const char *n_link, const char *n_comen, const char *n_comnl, const char *n_notes)
	: file(n_file), title(n_title), link(n_link), comen(n_comen), comnl(n_comnl), notes(n_notes), next(0) {}
	AbstractParseTreeCursor dataTC;
	File *file;
	const char *title;
	const char *link;
	const char *comen;
	const char *comnl;
	const char *notes;
private:
	Src *next;
};

struct Srcs
{
	Srcs() : src(0) { ref_next = &src; }
	void add(Src* n_src) 
	{
		*ref_next = n_src;
		ref_next = &n_src->next;
	}
	Src* src;
	virtual void fprint(FILE* fout) = 0;
private:
	Src** ref_next;
};

struct Book : public Srcs
{
	Book(const AbstractParseTreeCursor& n_dataTC, const char *n_id, const char *n_title)
	  : dataTC(n_dataTC), id(n_id), title(n_title) {}
	AbstractParseTreeCursor dataTC;
	const char *id;
	const char *title;
	virtual void fprint(FILE* fout) { fprintf(fout, "book %s", id); }
};

Book* books[500];
int nrBooks = 0;

Book* findBook(const char* id)
{
	for (int i = 0; i < nrBooks; i++)
		if (strcmp(books[i]->id, id) == 0)
			return books[i];
	return 0;
}


struct Exhibition : public Srcs
{
	Exhibition(const AbstractParseTreeCursor& n_dataTC, const char *n_id, const char *n_title, const char *n_from)
	  : dataTC(n_dataTC), id(n_id), title(n_title), from(n_from) {}
	AbstractParseTreeCursor dataTC;
	const char *id;
	const char *title;
	const char *from;
	virtual void fprint(FILE* fout) { fprintf(fout, "exhibition %s", id); }
};

Exhibition* exhibitions[500];
int nrExhibitions = 0;

Exhibition* findExhibition(const char* id)
{
	for (int i = 0; i < nrExhibitions; i++)
		if (strcmp(exhibitions[i]->id, id) == 0)
			return exhibitions[i];
	return 0;
}

struct WorkExhibition : public Srcs
{
	WorkExhibition(const AbstractParseTreeCursor& n_dataTC, Work* n_work, Exhibition *n_exhibition)
	  : dataTC(n_dataTC), work(n_work), exhibition(n_exhibition), next(0) {}
	AbstractParseTreeCursor dataTC;
	Work *work;
	Exhibition *exhibition;
	WorkExhibition *next;
	virtual void fprint(FILE* fout);
};

struct WorkBook : public Srcs
{
	WorkBook(const AbstractParseTreeCursor& n_dataTC, Work* n_work, Book *n_book)
	  : dataTC(n_dataTC), work(n_work), book(n_book), next(0) {}
	AbstractParseTreeCursor dataTC;
	Work *work;
	Book *book;
	virtual void fprint(FILE* fout);
	WorkBook *next;
};

struct Work : public Srcs
{
	Work(const AbstractParseTreeCursor& n_dataTC, const char *n_id, const char *n_title)
	  : dataTC(n_dataTC), id(n_id), title(n_title), exhibitions(0), books(0) {}
	AbstractParseTreeCursor dataTC;
	const char *id;
	const char *title;
	WorkExhibition *exhibitions;
	WorkExhibition *addExhibition(const AbstractParseTreeCursor& tc, Exhibition *exhibition)
	{
		WorkExhibition **ref = &exhibitions;
		while (*ref != 0)
			ref = &(*ref)->next;
		*ref = new WorkExhibition(tc, this, exhibition);
		return *ref;
	}
	WorkBook *books;
	WorkBook *addBook(const AbstractParseTreeCursor& tc, Book *book)
	{
		WorkBook **ref = &books;
		while (*ref != 0)
			ref = &(*ref)->next;
		*ref = new WorkBook(tc, this, book);
		return *ref;
	}
	virtual void fprint(FILE* fout) { fprintf(fout, "work %s", id); }
};

void WorkExhibition::fprint(FILE* fout) { fprintf(fout, "work exhibition %s %s", work->id, exhibition->id); }
void WorkBook::fprint(FILE* fout) { fprintf(fout, "work book %s %s", work->id, book->id); }

Work* works[1000];
int nrWorks = 0;	

Work* findWork(const char* id)
{
	for (int i = 0; i < nrWorks; i++)
		if (strcmp(works[i]->id, id) == 0)
			return works[i];
	return 0;
}



FILE* fout;


void parseSources(Srcs *srcs, const AbstractParseTreeCursor& elemTC)
{
	AbstractParseTreeCursor srcTC;
	if (!getMemberInList(elemTC, "src", srcTC))
		return;
	srcTC = srcTC.part(2);
	for (AbstractParseTreeIteratorCursor listIt(srcTC); listIt.more(); listIt.next())
	{
		AbstractParseTreeCursor elem(listIt);
		elem = elem.part(2);
		const char* img = getStringMemberValueInList(elem, "img");
		File *file = 0;
		if (img[0] != '\0')
		{
			file = files.findOrCreate(img);
			file->add(srcs);
		}
		
		const char* title = getStringMemberValueInList(elem, "title");
		const char* link = getStringMemberValueInList(elem, "link");
		const char* comen = getStringMemberValueInList(elem, "comen");
		const char* comnl = getStringMemberValueInList(elem, "comnl");
		const char* notes = getStringMemberValueInList(elem, "notes");
		srcs->add(new Src(elem, file, title, link, comen, comnl, notes));
	}
}


void analyse_dataSrc(AbstractParseTreeCursor dataSrcTC)
{
	AbstractParseTreeCursor booksTC;
	getTreeInList(dataSrcTC, "books", booksTC);
	booksTC = booksTC.part(1);
	for (AbstractParseTreeIteratorCursor listIt(booksTC); listIt.more(); listIt.next())
	{
		AbstractParseTreeCursor elem(listIt);
		elem = elem.part(2);
		const char* id = getStringMemberValueInList(elem, "id");
		const char* title = getStringMemberValueInList(elem, "title");
		//printf("Book:  id = %s, title = %s\n", id, title);
		Book *book = new Book(elem, id, title);
		books[nrBooks++] = book;

		parseSources(book, elem);
	}

	AbstractParseTreeCursor exhibtionsTC;
	getTreeInList(dataSrcTC, "exhibitions", exhibtionsTC);
	exhibtionsTC = exhibtionsTC.part(1);
	const char *prev_from_date = "1900";
	for (AbstractParseTreeIteratorCursor listIt(exhibtionsTC); listIt.more(); listIt.next())
	{
		AbstractParseTreeCursor elem(listIt);
		elem = elem.part(2);
		const char* id = getStringMemberValueInList(elem, "id");
		const char* title = getStringMemberValueInList(elem, "title");
		const char* from = getStringMemberValueInList(elem, "from");
		if (from[0] == '\0')
		{
			AbstractParseTreeCursor wwTC;
			if (getMemberInList(elem, "ww", wwTC))
			{
				for (AbstractParseTreeIteratorCursor wwIt(wwTC); wwIt.more(); wwIt.next())
				{
					AbstractParseTreeCursor wwElemTC(wwIt);
					wwElemTC = wwElemTC.part(2);
					from = getStringMemberValueInList(wwElemTC, "from");
					break;
				}
			}
		}
		if (from[0] == '\0')
			fprintf(fout, "dataSrc.js (%d) : Error: from date from Exhibition %s missing\n", elem.line(), id);
		else
		{
			int outcome = 0;
			const char *s1 = prev_from_date;
			const char *s2 = from;
			for (;*s1 != '\0' && *s2 != '\0'; s1++, s2++ )
				if (*s1 < *s2)
				{
					outcome = -1;
					break;
				}
				else if (*s2 < *s1)
				{
					outcome = 1;
					break;
				}
			if (outcome == -1 || (outcome == 0 && *s1 == '\0'))
				prev_from_date = from;
			if (outcome == 1)
				fprintf(fout, "dataSrc.js (%d) : Error: Exhibition %s started earlier than predecesor %s < %s\n", elem.line(), id, prev_from_date, from);
		}
		fprintf(fout, "Exhibition:  id = %s, title = %s, from: %s\n", id, title, from);
		Exhibition *exhibition = new Exhibition(elem, id, title, from);
		exhibitions[nrExhibitions++] = exhibition;
		
		parseSources(exhibition, elem);
	}

	AbstractParseTreeCursor worksTC;
	getTreeInList(dataSrcTC, "works", worksTC);
	worksTC = worksTC.part(1);
	for (AbstractParseTreeIteratorCursor workIt(worksTC); workIt.more(); workIt.next())
	{
		AbstractParseTreeCursor workTC(workIt);
		workTC = workTC.part(2);
		const char* id = getStringMemberValueInList(workTC, "id");
		const char* title = getStringMemberValueInList(workTC, "title");
		fprintf(fout, "Work:  id = %s, title = %s\n", id, title);
		Work* work = new Work(workTC, id, title);
		works[nrWorks++] = work;

		AbstractParseTreeCursor exhibitionsTC;
		if (getMemberInList(workTC, "exhibitions", exhibitionsTC))
		{
			for (AbstractParseTreeIteratorCursor exhibitionIt(exhibitionsTC); exhibitionIt.more(); exhibitionIt.next())
			{
				AbstractParseTreeCursor exhibitionTC(exhibitionIt);
				exhibitionTC = exhibitionTC.part(2);

				const char* exhibition_id = getStringMemberValueInList(exhibitionTC, "id");
				Exhibition* exhibition = findExhibition(exhibition_id);
				if (exhibition == 0)
					fprintf(fout, "dataSrc.js (%d) : Error: exhibition %s (with work %s) does not exist\n", exhibitionTC.line(), exhibition_id, id);
				else
				{
					WorkExhibition *workExhibition = work->addExhibition(exhibitionTC, exhibition);
					parseSources(workExhibition, exhibitionTC); 
				}
			}
		}
		AbstractParseTreeCursor booksTC;
		if (getMemberInList(workTC, "books", booksTC))
		{
			for (AbstractParseTreeIteratorCursor bookIt(booksTC); bookIt.more(); bookIt.next())
			{
				AbstractParseTreeCursor bookTC(bookIt);
				bookTC = bookTC.part(2);

				const char* book_id = getStringMemberValueInList(bookTC, "id");
				Book* book = findBook(book_id);
				if (book == 0)
					fprintf(fout, "dataSrc.js (%d) : Error: book %s (with work %s) does not exist\n", bookTC.line(), book_id, id);
				else
				{
					WorkBook *workBook = work->addBook(bookTC, book);
					parseSources(workBook, bookTC); 
				}
			}
		}
		parseSources(work, workTC);
	}
}

int line_nr = 0;

class HTMLLineParser
{
public:
	HTMLLineParser(const char* buffer) : _s(buffer) { line_nr++; next(); }
	bool more() { return _more; }
	const char* tag() { return _tag; }
	bool is_tag(const char *tag) { return strcmp(tag, _tag) == 0; }
	const char href_type() { return _href_type; }
	const char* href_code() { return _href_code; }
	const char* href() { return _text; }
	const char* text() { return _text; }
	bool empty_code() { return _href_code[0] == '\0' || _href_code[0] == '?'; }
	Book* book() { return _book; }
	Exhibition* exhibition() { return _exhibition; }
	Work* work() { return _work; }
	void next()
	{
		_more = false;
		if (*_s == '\0' || *_s == '\n')
			return;
		_tag[0] = '\0';
		_text[0] = '\0';
		_href_type = '\0';
		_book = 0;
		_exhibition = 0;
		_work = 0;
		if (*_s == '<')
		{
			_more = true;
			_s++;
			char *t = _tag;
			while (*_s != ' ' && *_s != '>' && *_s != '\0' && *_s != '\n')
				*t++ = *_s++;
			*t = '\0';
			if (_tag[0] == 'A' && _tag[1] == '\0')
			{
				if (strncmp(_s, " HREF=\"", 7) != 0)
					fprintf(fout, "notes.html (%d) : Error: malformed A HREF\n", line_nr);
				else
				{
					_s += 7;
					t = _text;
					while(*_s != '"' && *_s != '\0' && *_s != '\n')
						*t++ = *_s++;
					*t = '\0';
					if (strncmp(_text, "EnDynTest.html?|", 16) == 0)
					{
						t = _text + 16;
						if ((*t == 'e' || *t == 'b' || *t == 'w') && t[1] == '|')
						{
							_href_type = *t;
							_href_code = t + 2;
							if (_href_type == 'b')
							{
								if (empty_code())
									fprintf(fout, "notes.html (%d) : Info: Need to determine book code\n", line_nr);
								else
								{
									_book = findBook(_href_code);
									if (_book == 0)
										fprintf(fout, "notes.html (%d) : Error: unknown book code %s\n", line_nr, _href_code);
								}
							}
							else if (_href_type == 'e')
							{
								if (empty_code())
									fprintf(fout, "notes.html (%d) : Info: Need to determine exhibition code\n", line_nr);
								else
								{
									_exhibition = findExhibition(_href_code);
									if (_exhibition == 0)
										fprintf(fout, "notes.html (%d) : Error: unknown exhibition code %s\n", line_nr, _href_code);
								}
							}
							else if (_href_type == 'w')
							{
								if (empty_code())
									fprintf(fout, "notes.html (%d) : Info: Need to determine work code\n", line_nr);
								else
								{
									_work = findWork(_href_code);
									if (_work == 0)
										fprintf(fout, "notes.html (%d) : Error: unknown work code %s\n", line_nr, _href_code);
								}
							}
							else
								fprintf(fout, "notes.html (%d) : Error: unknown type %c\n", line_nr, _href_type);
						}
					}
					else if (strncmp(_text, "EnDynTest.html", 14) == 0)
						fprintf(fout, "notes.html (%d) : Malformed link\n", line_nr);
				}
			}
			while (*_s != '>' && *_s != '\0' && *_s != '\n')
				_s++;
			if (*_s == '>')
				_s++;
		}
		else
		{
			char* t = _text;
			while (*_s != '\0' && *_s != '\n' && *_s != '<')
			{
				if (*_s != ' ')
					_more = true;
				*t++ = *_s++;
			}
			*t = '\0';
			if (*_s == '<')
				_more = true;
		}
	}
private:
	const char* _s;
	bool _more;
	char _tag[10];
	char _href_type;
	char *_href_code;
	Book *_book;
	Exhibition *_exhibition;
	Work *_work;
	char _text[500];
};


void analyse_notes()
{
	char buffer[1000];
	FILE* f = fopen("..\\..\\PS\\notes.html", "rt");
	while (fgets(buffer, 9999, f))
	{
		line_nr++;
		if (strncmp(buffer, "<!--HIER-->", 11) == 0)
			break;
	}
	//char *img = empty_string;
	//char *title = empty_string;
	//bool prev_img = false;
	//bool in_ul = false;
	//Book *book = 0;
	//bool open_square = false;
	//bool p_img_used = false;
	Exhibition *header_exhibition = 0;
	Book *header_book = 0;
	Work *header_work = 0;
	while (fgets(buffer, 9999, f))
	{
		HTMLLineParser lineParser(buffer);

		if (lineParser.is_tag("H2") || lineParser.is_tag("H3") || lineParser.is_tag("H4"))
		{
			lineParser.next();
			header_exhibition = 0;
			header_book = 0;
			header_work = 0;
			if (lineParser.is_tag("A") && lineParser.href_type() != '\0')
			{
				header_exhibition = lineParser.exhibition();
				header_book = lineParser.book();
				header_work = lineParser.work();
			}
		}
		else
		{
			for (; lineParser.more(); lineParser.next())
			{
				if (lineParser.is_tag("A"))
				{
					if (lineParser.href_type() == '\0')
					{
						File* file = files.findOrCreate(lineParser.href());
						lineParser.next();
					}
				}
			}
		}
		/*
		if (buffer[0] == '\n' || strcmp(buffer, "<P>\n") == 0)
		{	// Skip
		}
		else if (buffer[0] == '<' && buffer[1] == 'H' && buffer[2] >= '2' && buffer[2] <= '4')
		{
			char *s = buffer + 
		else if (strncmp(buffer, "<A HREF=\"f/P", 12) == 0)
		{
			char *img_s = buffer + 9;
			char *img_e = img_s;
			while (*img_e != '"' && *img_e != '\0')
				img_e++;
			img = allocString(img_s, img_e);
			char *s_close_A = strstr(buffer, "</A>");
			char *title_s = s_close_A + 4;
			while (*title_s == ' ')
				title_s++;
			char *title_e = strstr(s_close_A, "<BR>");
			if (title_e == 0)
				title_e = strstr(s_close_A, "\n");
			title = allocString(title_s, title_e);
			if (book != 0)
				book->add(new Src(img, title, false));
			else if (sources.isNew(img))
			{
				if (!prev_img)
				{
					printf("title:\"%s\",src:[", titleLine);
					open_square = true;
				}
				else
					printf(",");
				prev_img = true;			
				printf("{");
				if (title != empty_string)
					printf("title:\"%s\",", title);
				printf("img:\"%s\"}", img);
			}
		}
		else if (strncmp(buffer, "<A HREF=\"p/", 11) == 0)
		{
			if (!p_img_used && img != empty_string && sources.isNew(img))
				printf("src:[{img:\"%s\"}]\n", img);
			p_img_used = false;
			char *img_s = buffer + 9;
			char *img_e = img_s;
			while (*img_e != '"' && *img_e != '\0')
				img_e++;
			img = allocString(img_s, img_e);
			char *s_close_A = strstr(buffer, "</A>");
			char *title_s = s_close_A + 4;
			while (*title_s == ' ')
				title_s++;
			char *title_e = strstr(s_close_A, "<BR>");
			if (title_e == 0)
				title_e = strstr(s_close_A, "\n");
			title = allocString(title_s, title_e);
			prev_img = true;
			book = 0;
		}
		else if (strstr(buffer, "EnDynTest.html?|w|") != 0)
		{
			char *s = strstr(buffer, "EnDynTest.html?|w|") + 22;
			char *work_b = s;
			while (*s != '"' && *s != '\0')
				s++;
			char *work_id = allocString(work_b, s);
			Work* work = 0;
			for (int i = 0; i < nrWorks; i++)
				if (strcmp(work_id, works[i]->id) == 0)
				{
					work = works[i];
					break;
				}
			if (work != 0)
			{
				if (prev_img)
				{
					work->add(new Src(img, title, false, book));
					p_img_used = true;
				}
			}
		}
		else if (strstr(buffer, "<UL>"))
			in_ul = true;
		else if (strstr(buffer, "</UL>"))
			in_ul = false;
		else if (!in_ul)
		{
			if (prev_img)
			{
				if (open_square)
				{
					printf("]\n");
					open_square = false;
				}
				prev_img = false;
				img = empty_string;
				title = empty_string;
			}
			if (strstr(buffer, "<A HREF=\"EnDynTest.html?|b|") == buffer)
			{
				char bookId[20];
				int i = 0;
				char *s = buffer + 31;
				for (; i < 20 && *s != '"'; i++)
					bookId[i] = *s++;
				bookId[i] = '\0';
				book = 0;
				for (int j = 0; j < nrBooks; j++)
					if (strcmp(books[i]->id, bookId) == 0)
					{
						book = books[i];
						break;
					}
				if (book != 0)
					strcpy(titleLine, book->title);
			}
			else
			{
				strcpy(titleLine, buffer);
				char *tl_e = strstr(titleLine, "<BR>");
				if (tl_e == 0)
					tl_e = strstr(titleLine, "\n");
				if (tl_e != 0)
					*tl_e = '\0';
				book = 0;
				// First find book whoes largest
				int match_len = 0;
				for (int j = 0; j < nrBooks; j++)
					if (strlen(books[j]->title) > match_len && strstri(titleLine, books[j]->title))
					{
						book = books[j];
						match_len = strlen(books[j]->title);
					}
				if (match_len == 0)
				{
					match_len = 10000;
					for (int j = 0; j < nrBooks; j++)
						if (strlen(books[j]->title) < match_len && strstri(books[j]->title, titleLine))
						{
							book = books[j];
							match_len = strlen(books[j]->title);
						}
				}
			}
		}
		*/
	}
	//if (!p_img_used && img != empty_string)
	//	printf("src:[{img:\"%s\"}]\n", img);

}

int main(int argc, char* argv[])
{
	AbstractParseTree dataSrcGrammarTree;
	AbstractParseTree dataSrcTree;
	if (!parse_dataSrc(dataSrcGrammarTree, dataSrcTree))
		return -1;
	
	//dataSrcTree.print(stdout, false);
	fout = fopen("..\\..\\PS\\errors.txt", "wt");

	analyse_dataSrc(dataSrcTree);
	
	analyse_notes();

	for (Files::iterator it(files); it.more(); it.next())
	{
		File& file = it.value();
		fprintf(fout, "Image %s ", file.key.val());
		for (File::SrcsIterator srcsIt(file); srcsIt.more(); srcsIt.next())
		{
			fprintf(fout, " in ");
			srcsIt.value()->fprint(fout);
		}
		if (!file.inSrcs())
			fprintf(fout, " missing");
		fprintf(fout, "\n");
	}

	fclose(fout);

	unparse_dataSrc("..\\..\\PS\\dataSrc_out.js", dataSrcGrammarTree, dataSrcTree);
	
	return 0;
}

/*
char buffer[10000];

char *empty_string = "";

char *allocString(char *b, char *e)
{
	int len = e - b;
	if (len == 0) return empty_string;
	char *result = new char[len+1];
	strncpy(result, b, len);
	return result;
}

char *allocLine(char *buffer)
{
	int len = strlen(buffer);
	if (len == 0) return empty_string;
	if (buffer[len-1] == '\n')
		len--;
	char *result = new char[len+1];
	strncpy(result, buffer, len);
	return result;
}

char *strstri(char *a, char *b)
{
	if (*b == '\0')
		return 0;
	for (; *a != '\0'; a++)
	{
		char *sa = a;
		char *sb = b;
		for (; *sa != '\0' && *sb != '\0'; sa++, sb++)
			if (tolower(*sa) != tolower(*sb))
				break;
		if (*sb == '\0')
			return a;
		if (*sa == '\0')
			return 0;
	}
	return 0;
}

struct Book;

struct Src
{
	Src(char *n_img, char *n_title, bool n_old, Book *n_book = 0) : img(n_img), title(n_title), old(n_old), book(n_book), next(0) {}
	char *img;
	char *title;
	bool old;
	Book *book;
	Src *next;
};
struct Srcs
{
	Srcs() { src = 0; }
	void add(Src* n_src) 
	{
		Src** refsrc = &src;
		for (; *refsrc != 0; refsrc = &(*refsrc)->next)
			if (strcmp((*refsrc)->img, n_src->img) == 0)
				return;
		*refsrc = n_src;
	}
	bool hasNew()
	{
		for (Src *i = src; i != 0; i = i->next)
			if (!i->old)
				return true;
		return false;
	}
	bool isNew(char *img)
	{
		for (Src *i = src; i != 0; i = i->next)
			if (i->old && strcmp(i->img, img) == 0)
				return false;
		return true;
	}
	Src* src;
};

struct Book : public Srcs
{
	Book(char *n_id, int n_linenr, char* n_title, char* n_line) : id(n_id), linenr(n_linenr), title(n_title), line(n_line) {} 
	char *id;
	int linenr;
	char *title;
	char *line;
};
Book* books[500];
int nrBooks = 0;

struct Work : public Srcs
{
	Work(char *n_id, int n_linenr, char *n_line) : id(n_id), linenr(n_linenr), line(n_line) {} 
	char *id;
	int linenr;
	char *line;
};

Work* works[1000];
int nrWorks = 0;

int main(int argc, char *argv)
{
	FILE *f = fopen("dataSrc.js","rt");
	int linenr = 0;

	Srcs sources;	
	while (fgets(buffer, 9999, f))
	{
		linenr++;
		if (strncmp(buffer, " books:", 7) == 0)
			break;
	}
	int c = 0;
	Book *cur_book = 0;
	while (fgets(buffer, 9999, f))
	{
		linenr++;
		if (strncmp(buffer, " works:", 7) == 0)
			break;
		if (strncmp(buffer, "  { id:\"", 8) == 0)
		{
			char* s = buffer + 8;
			char* id_b = s;
			while (*s != '"')
				s++;
			char* id_e = s;
			s++;
			while (*s != '"')
				s++;
			s++;
			char* title_b = s;
			while (*s != '"')
				s++;
			char* title_e = s;
			Book *book = new Book(allocString(id_b, id_e), linenr, allocString(title_b, title_e), allocLine(buffer));
			books[nrBooks++] = book;
			cur_book = book;
		}
		char *s = buffer;
		while ((s = strstr(s, "img:\"")) != 0)
		{
			s += 5;
			char *img_s = s;
			while (*s != '"')
				s++;
			char* img_e = s;
			s++;
			if (cur_book != 0)
			{
				char *img = allocString(img_s, img_e);
				cur_book->add(new Src(img, empty_string, true));
				sources.add(new Src(img, empty_string, true));
			}
		}
	}
	//for (int i = 0; i < nrBooks; i++)
	//	printf("%3d %10s %s\n", books[i]->linenr, books[i]->id, books[i]->line);
	printf("Books: %d\n", nrBooks);
	
	Work *cur_work = 0;
	while (fgets(buffer, 9999, f))
	{
		linenr++;
		if (strncmp(buffer, " programs", 9) == 0)
			break;
		if (strncmp(buffer, "  { id:\"", 8) == 0)
		{
			char* s = buffer + 8;
			char* id_b = s;
			while (*s != '"')
				s++;
			char* id_e = s;
			/ *
			s++;
			while (*s != '"')
				s++;
			s++;
			char* title_b = s;
			while (*s != '"')
				s++;
			char* title_e = s;
			* /
			Work *work = new Work(allocString(id_b, id_e), linenr, allocLine(buffer));
			works[nrWorks++] = work;
			cur_work = work;
		}
		char *s = buffer;
		while ((s = strstr(s, "img:\"")) != 0)
		{
			s += 5;
			char *img_s = s;
			while (*s != '"')
				s++;
			char* img_e = s;
			s++;
			if (cur_work != 0)
			{
				char *img = allocString(img_s, img_e);
				cur_work->add(new Src(img, empty_string, true));
				sources.add(new Src(img, empty_string, true));
			}
		}
	}
	//for (int i = 0; i < nrWorks; i++)
	//	printf("%3d %10s %s\n", works[i]->linenr, works[i]->id, works[i]->line);
	printf("Works: %d\n", nrWorks);

	fclose(f);

	printf("\n\n");
	for (int i = 0; i < nrBooks; i++)
	{
		Book* book = books[i];
		if (book->hasNew())
		{
			printf("dataSrc.js:%d:", book->linenr);
			char *endline = strstr(book->line, ", works:[");
			if (endline == 0)
			{
				for (char *s = book->line; *s != 0; s++)
					if (s[0] == '}' && s[1] == ',')
					{
						endline = s;
						while (*(endline-1) == ' ')
							endline--;
					}
			}
			if (endline == 0)
				printf("%s // src:[", book->line);
			else
			{
				for (char *s = book->line; s < endline; s++)
					printf("%c", *s);
				printf(",src:[");
			}
			bool first = true;
			for (Src *src = book->src; src != 0; src = src->next)
			{
				if (!src->old)
				{
					if (!first)
						printf(",");
					first = false;
					printf("{");
					if (src->title != empty_string)
						printf("title:\"* %s\",", src->title);
					else
						printf("title:\"*\",");
					printf("img:\"%s\"}", src->img);
				}
			}
			if (endline == 0)
				printf("]\n");
			else
				printf("]%s\n", endline);
		}
	}
	printf("\n\n");
	for (int i = 0; i < nrWorks; i++)
	{
		Work *work = works[i];
		if (work->hasNew())
		{
			printf("dataSrc.js:%d:", work->linenr);
			char *endline = 0;
			for (char *s = work->line; *s != 0; s++)
				if (s[0] == '}' && s[1] == ',')
				{
					endline = s;
					while (*(endline-1) == ' ')
						endline--;
				}
			if (endline == 0)
				printf("%s // src:[", work->line);
			else
			{
				for (char *s = work->line; s < endline; s++)
					printf("%c", *s);
				printf(",src:[");
			}
			char *end = strstr(work->line, " },");
			if (end == 0)
				end = strstr(work->line, "},");
			bool first = true;
			for (Src *src = work->src; src != 0; src = src->next)
			{
				if (!src->old)
				{
					if (!first)
						printf(",");
					first = false;
					printf("{");
					if (src->book != 0)
						printf("/ *book:%s* /", book->id);
					if (src->title != empty_string)
						printf("title:\"* %s\",", src->title);
					else
						printf("title:\"*\",");
					printf("img:\"%s\"}", src->img);
				}
			}
			if (endline == 0)
				printf("]\n");
			else
				printf("]%s\n", endline);
		}
	}
}
*/
