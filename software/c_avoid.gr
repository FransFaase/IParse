primary_expr
        : ident
        | int
        | double
        | char
        | string
        | "(" expr ")"
        .

postfix_expr
        : postfix_expr "[" expr "]"  [array]
        | postfix_expr "(" assignment_expr LIST OPT ")"  [call]
        | postfix_expr "." ident  [field]
        | postfix_expr "->" ident  [fieldderef]
        | postfix_expr "++"  [post_inc]
        | postfix_expr "--"  [post_dec]
        | primary_expr
        .

unary_expr
        : "++" unary_expr  [pre_inc]
        | "--" unary_expr  [pre_dec]
        | "&" cast_expr  [address_of]
        | "*" cast_expr  [deref]
        | "+" cast_expr  [plus]
        | "-" cast_expr  [min]
        | "~" cast_expr  [invert]
        | "!" cast_expr  [not]
        | "sizeof" ( unary_expr [typeof]
                   | "(" ident ")"  
                   )  [sizeof]
        | postfix_expr
        .

cast_expr
        : "(" abstract_declaration ")" cast_expr  [cast]
        | unary_expr
        .

l_expr1 : l_expr1 "*" cast_expr  [times]
        | l_expr1 "/" cast_expr  [div]
        | l_expr1 "%" cast_expr  [mod]
        | cast_expr
        .
l_expr2 : l_expr2 "+" l_expr1  [add]
        | l_expr2 "-" l_expr1  [sub]
        | l_expr1 
        .
l_expr3 : l_expr3 "<<" l_expr2  [ls]
        | l_expr3 ">>" l_expr2  [rs]
        | l_expr2
        .
l_expr4 : l_expr4 "<=" l_expr3  [le]
        | l_expr4 ">=" l_expr3  [ge]
        | l_expr4 "<"  l_expr3  [lt]
        | l_expr4 ">"  l_expr3  [gt]
        | l_expr4 "==" l_expr3  [eq]
        | l_expr4 "!=" l_expr3  [ne]
        | l_expr3
        .
l_expr5 : l_expr5 "^"  l_expr4 [bexor] | l_expr4 .
l_expr6 : l_expr6 "&"  l_expr5 [land]  | l_expr5 .
l_expr7 : l_expr7 "|"  l_expr6 [lor]   | l_expr6 .
l_expr8 : l_expr8 "&&" l_expr7 [land]  | l_expr7 .
l_expr9 : l_expr9 "||" l_expr8 [lor]   | l_expr8 .

conditional_expr
        : l_expr9 "?" l_expr9 ":" conditional_expr  [if_expr]
        | l_expr9
        .

assignment_expr
        : unary_expr assignment_operator assignment_expr  [assignment]
        | conditional_expr
        .

assignment_operator
        : "="   [ass] 
        | "*="  [times_ass]
        | "/="  [div_ass]
        | "%="  [mod_ass] 
        | "+="  [add_ass]
        | "-="  [sub_ass]
        | "<<=" [sl_ass]
        | ">>=" [sr_ass]
        | "&="  [and_ass]
        | "|="  [or_ass]
        | "^="  [exor_ass]
        .

expr    : assignment_expr LIST.

constant_expr
        : conditional_expr
        .

declaration
        : ( storage_class_specifier | type_specifier ) SEQ OPT AVOID
          ( ( declarator ("=" initializer) OPT) LIST OPT ";"  [decl]
          | func_declarator "(" parameter_declaration_list OPT ")"
            ( ";" | "{" decl_or_stat "}" )  [new_style]
          | func_declarator "(" ident_list OPT ")" declaration SEQ OPT
            "{" decl_or_stat "}"  [old_style]
          )
        .

storage_class_specifier
        : "typedef"  [typedef]
        | "extern"   [extern]
        | "static"   [static]
        | "auto"     [auto]
        | "register" [register]
        .

type_specifier
        : "char"     [char]
        | "short"    [short]
        | "int"      [int]
        | "long"     [long]
        | "signed"   [signed]
        | "unsigned" [unsigned]
        | "float"    [float]
        | "double"   [double]
        | "const"    [const]
        | "volatile" [volatile]
        | "void"     [void]
        | struct_or_union_specifier  
        | enum_specifier
        | ident 
        .

struct_or_union_specifier
        : "struct" ident "{" struct_declaration SEQ "}"  [struct_d]
        | "struct" "{" struct_declaration SEQ "}"  [struct_n]
        | "struct" ident  [struct] 
        | "union" ident "{" struct_declaration SEQ "}"  [union_d]
        | "union" "{" struct_declaration SEQ "}"  [union_n]
        | "union" ident  [union]
        .


struct_declaration
        : type_specifier struct_declaration  [type]
        | struct_declarator LIST ";"  [strdec]
        .

struct_declarator
        : declarator (":" constant_expr) OPT  [record_field]
        .

enum_specifier
        : "enum" ident ("{" enumerator LIST "}")  [enum]
        .

enumerator
        : ident ("=" constant_expr) OPT  [enumerator]
        .

func_declarator 
        : "*" "const" OPT func_declarator  [pointdecl]
        | "(" func_declarator ")" 
        | ident
        .
        
declarator
        : "*" "const" OPT declarator  [pointdecl]
        | "(" declarator ")" 
        | declarator "[" constant_expr OPT "]"  [array]
        | declarator "(" abstract_declaration_list OPT ")"  [function]
        | ident
        .

abstract_declaration_list
        : abstract_declaration
          ( "," ( "..." | abstract_declaration_list )) OPT 
        .
parameter_declaration_list
        : parameter_declaration
          ( "," ( "..." | parameter_declaration_list )) OPT
        .
ident_list 
        : ident ( "," ( "..." | ident_list )) OPT 
        .

parameter_declaration
        : type_specifier parameter_declaration  [type]
        | declarator
        | abstract_declarator OPT
        .

abstract_declaration
        : type_specifier parameter_declaration  [type]
        | abstract_declarator OPT
        .

abstract_declarator
        : "*" "const" OPT abstract_declarator  [pointdecl]
        | "(" abstract_declarator ")"
        | abstract_declarator "[" constant_expr OPT "]"  [array]
        | abstract_declarator "(" parameter_declaration_list ")"  [func]
        |
        .

initializer
        : assignment_expr
        | "{" initializer LIST "," OPT "}"  [initializer]
        .
decl_or_stat 
        : declaration SEQ OPT AVOID statement SEQ OPT
        .

statement
        : (ident | "case" constant_expr | "default") ":" statement  [label]
        | "{" decl_or_stat "}"
        | expr OPT ";"
        | "if" "(" expr ")" statement  ("else" statement) OPT  [if]
        | "switch" "(" expr ")" statement  [switch]
        | "while" "(" expr ")" statement  [while]
        | "do" statement "while" "(" expr ")" ";"  [do]
        | "for" "(" expr OPT ";" 
                    expr OPT ";" 
                    expr OPT ")" statement  [for]
        | "goto" ident ";"  [goto]
        | "continue" ";"  [cont]
        | "break" ";"  [break]
        | "return" expr OPT ";"  [ret]
        .

root    : declaration SEQ OPT eof
        .

